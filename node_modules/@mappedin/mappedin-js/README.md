# mapview-js

Interactive map viewer with 2D and 3D support.

Installation instructions with videos can be found [here](https://drive.google.com/open?id=17tJOebwaRP-kPwqeO0YqST_YPJTbniHdvSfmTbCkEi0).

## Local Usage

To run your own instance of the demo page (for example, to test features/bugfixes in development; to test how things will look if you make changes in CMS; etc.) just follow these steps:

1. Clone the repo
2. `yarn`
3. `yarn dev` to start the dev server. This will open the browser for you.
4. Put your environment-appropriate (i.e., production vs. staging) credentials, venue slug and perspective in the settings box on the left.
5. If you are only doing a local test, you should use the staging environment. You can do this by choosing "Staging" in the settings box.
6. Hit submit in the settings box. The page will refresh and the map should now be loaded successfully.

**If you are going to be using this tool often, copy `examples/MappedinConfig.template.js` to `examples/MappedinConfig.js` and put your credentials in there.**

_Note that you cannot mix and match credentials for production and staging environments._

If you need to obtain credentials, or have any other questions, talk to anyone on the consumer team.

## Releasing

To cut a fresh release, you must update the yarn version and tag it in github. The Jenkins job will publish the release externally and update the private Yarn repo.

1. Ensure you are on the latest Master branch
2. yarn version [--major|--minor|--patch], ie `yarn version --minor`
3. git checkout -b <version number>, ie `git checkout -b 1.30.0`
4. git push origin <version number> --follow-tags, ie `git push origin 1.30.0 --follow-tags`
5. PR your branch back into master for the normal review process
6. Once it's merged, tag a release with release notes
7. Build the [websdk-production](https://taiga.mappedin.com/job/websdk-production/) job in Jenkins, using your new version tag as the parameter
8. Send release notes to Ian for publication on the KB and alerts to partners.

## Integration

The demo is useful for testing, shows how the mapview is supposed to be used, and does some neat demos. However, you probably want to actually integrate mappedin.js into your application itself. It is built to either be script tagged or required in.

To setup the map view, you must first perform a test to determine whether the browser can handle 3D or not, or force the mode of the viewer. Either way, first setup an init function that can be called in either situation.

```js
var init = function(error, success) {
  Mappedin.init(options, function(error, success) {
    if (error) {
      console.log('Mappedin error', error);
    }
    else {
      initWithData(success);
    }
  }
}
```

We wrap the `Mappedin.init` function in our own because the callback in the upcoming functions passes in the `error` and `success` parameters. This way we can pass in an options object as well. The options object contains your access info, API fields to fetch and things like which venue and perspective you want to work with.

The easiest way to handle the cases is to read a parameter and use a switch statement to get the program going. In this example, the parameter `forceMode` is taken from the URL, and uses the `init` function from above.

```js
switch (forceMode) {
	case '2d':
	case '2D':
		Mappedin.force2D(init);
		break;
	case '3d':
	case '3D':
		Mappedin.force3D(init);
		break;
	case 'test':
		Mappedin.forceTest(canvas, init);
		break;
	default:
		Mappedin.test3D(canvas, init);
}
```

If successful, `success` in `init` will contain the data you want to proceed with. You can access it in the callback like so:

```js
function initWithData(response) {
  var data = response._data;
```

In this function we will also call for the map view.

```js
function initWithData(response) {
	// define this globally for easy access
	data = response._data;
	var mapViewOptions = {
		onDataLoaded: initPostMapLoaded
	};
	mapView = new Mappedin.MapView(canvas, data, mapViewOptions);
}
```

The MapView constructor takes your container (just a `div`, you can use `document.getElementById` or similar to access it), your data, and an options object. Options are optional, just pass a `null` to use the defaults. One useful option is the `onDataLoaded` callback to work with when your maps and data are all ready to go.

In your callback you have a chance to override some functions to create the behaviour you want. Most notably, you will want to override `onPolygonClicked` and `onNothingClicked`.

```js
function mapLoaded() {
  // Clear out the highlighted polygons when nothing is clicked on
  mapView.onNothingClicked() {
    mapView.clearAllPolygonColors();
  }
  // Turn the polygon red when clicked
  mapView.onPolygonClicked = function(polygon) {
    mapView.clearAllPolygonColors();
    mapView.setPolygonColor(polygon, 0xff0000, true);
    return false;
  }
}
```

This is also the place you want to define your interactive polygons. To do this, we can just simply loop through the locations and their polygons, using MapView's `addInteractivePolygon`. Typically these will be polygons that have a location associated with them, though you may also want to look at polygons that have an entrance node. The latter should be a superset of the former, including polygons that are currently vacant.

```js
var locations = data.locations;
for (var i = 0, iLen = locations.length; i < iLen; ++i) {
	var location = locations[i];
	var polygons = location.polygons;
	for (var j = 0, jLen = polygons.length; j < jLen; ++j) {
		var polygon = polygons[i];
		mapView.addInteractivePolygon(polygon);
	}
}
```

This should be enough to get a basic map view running.

## Helper Functions

One thing useful in creating custom behaviours in your map view is being able to get specific data when you need it. These functions utilize lodash's `find` function to sift through the data. Since we don't need most of the library, it is useful to only include the pieces that do get used. In these examples, the program is compiled by Babel and is using ES6 syntax. We include find via `import find from 'lodash.find'`.

```js
// Gets a location object from a polygon's ID
const getLocationByPolygonId = pid => {
	return find(venue.locations, location => {
		return find(location.polygons, { id: pid });
	});
};

// Gets a location by its ID
const getLocationById = lid => {
	return find(venue.locations, { id: lid });
};

// Gets a polygon object from a location by ID
const getPolygonInLocationId = (pid, location) => {
	return find(location.polygons, { id: pid });
};

// Gets a node object by map ID
// Can be used in directions
const getNodeByPolygonMap = (mid, location) => {
	return find(location.nodes, { map: mid });
};

// Gets a map by ID
const getMapById = mid => {
	return find(venue.maps, { id: mid });
};
```

## Drawing Directions

Part of the location data structure is a `directionsTo` function to get data we can use to draw paths on our maps. To get the data you can use two location objects and the API will figure out the best entrance nodes to depart from, and navigate to. This example assumes we have already found `departure` and `destination` and they are location objects. `options` is assumed to be `null` in this example, but you can pass in the field `accessible` as `true` to get accessible directions.

```js
function drawDirections(error, data) {
	if (!error) {
		// Use our helper to get the first map from the path
		var firstMap = getMapById(data.path[0].map);
		// Switch to the map the directions start on
		// You should check if this map is different from the current map here
		mapView.setMap(firstMap);
		mapView.removeAllPaths();
		var pathOptions = {
			color: 0x007afb,
			radius: 12
		};
		mapView.drawPath(data.path, pathOptions);
	}
}

departure.directionsTo(destination, options, drawDirections);
```

## ES6 integration

#### External Dependencies

The following need to be provided by those using the SDK in Yarn projects:

- three
- @tweenjs/tween.js
- geodesy
- core-js@^2.0.0
- @mappedin/mapbox-gl (if using outdoor context)

### Installation

```
yarn add @mappedin/mappedin-js
```

The ES6 package is split into 3 modules:

#### mappedin-js

```
import * as Mappedin '@mappedin/mappedin-js';

Mappedin.test3D();...

```

#### mappedin-js/mapview3D

```
import MapView3D as Mappedin '@mappedin/mappedin-js/mapview3D';

new MapView3D();...

```

#### mappedin-js/mapview2D

```
import MapView2D as Mappedin '@mappedin/mappedin-js/mapview2D';

new MapView2D();...

```

## Screenshot test framework

**Table of contents**

1. [General](#general)
2. [Local Cypress Usage](#local-cypress-usage)
3. [Jenkins Components](#jenkins-components)
   - [Pull request Pipeline job](#pipeline-job)
   - [Individual screenshot updating job](#screenshot-update-job)

## General

The screenshot tests work using the Cypress framework. It uses the cypress-plugin-snapshots yarn package which has been configured in cypress/plugins/index.js. It essentially functions by taking a screenshot on request (generally at the end of a test scenario) and comparing it to a stored baseline. If there is a baseline, it will compare the new image against the baseline. If there are any differences, a diff-image will be generated highlighting where the changes are.

See Cypress here: https://www.cypress.io/

See cypress-image-snapshot here: https://github.com/meinaart/cypress-plugin-snapshots

- Baseline screenshots get saved to `cypress/integration/__image_snapshots__`, and end in `#0.png`
- The spec files should only be added to `cypress/integration/`.

## Local Cypress Usage

In order to run cypress locally you need to :

1.  `yarn`
2.  Make a `cypress.env.json` file in the root of the repo (you can see what the format should be by looking at `cypress-sample.env.json` which is included in the repo and enter the **clientId** and **clientSecret**. (You can probably copy the ones being used as the defaults from this [jenkins job](https://jenkins.mappedin.com/job/screenshots-test/build)).
3.  `yarn screenshot-test-server` (this starts up a server so that the index.html in UI-Automation can load mappedin.js as a script tag)
4.  Make a build that is fit to be used by cypress: `yarn build-test-screenshot`
5.  Run cypress by either:
    - `yarn cypress-open` (this will open the cypress GUI which is really helpful for watching and debugging your tests)
    - `yarn cypress-run` (this will just run your tests headlessly and output the results in the console)

## Jenkins Components

### Pipeline job

The groovy pipeline job that runs automatically on web-sdk pull requests. This job will run all of the tests and be the gatekeeper to prevent merging unless all tests pass.

If any of the tests fail, there will be diff images stored in the artifacts for that pipeline, alongside the expected screenshots (for comparison). The diff images will end in `#0.diff.png` and the actual images (if you wish to update the baseline) will end in `#0.actual.png`.
