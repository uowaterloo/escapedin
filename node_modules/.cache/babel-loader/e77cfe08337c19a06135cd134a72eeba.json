{"ast":null,"code":"var _jsxFileName = \"/Users/raghavsethi/Desktop/mappedin/software/webspring/src/components/apps/map-view/index.js\";\nimport React, { useContext } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { useHistory } from \"react-router-dom\";\nimport Mappedin from \"@mappedin/mappedin-js/builds/mappedin\";\nimport Keys from \"../../../keys\";\nimport Spinner from \"../../shared/spinner\";\nimport MappedinMap from \"./MappedinMapview\";\nimport Markers from \"./markers\";\nimport { useSequentialSelections, useMarkerManager, getLocationForPolygon, getPolygonForLocation } from \"./utils\";\nimport { Wrapper, Row, LoadingScreen, StyledStatusBar, InterfaceContainer } from \"./index.style\";\nimport { StateContext, ActionTypes } from \"../../util/useApplicationState\";\nconst SelectionOrder = [\"5b1a820697e366793c000083\", //ptolemy\n\"5b1a81db97e366793c000081\", //mercator\n\"5b1a817c97e366793c000080\", //da vinci\n\"5b1a814f97e366793c00007f\", //tomlinson\n\"5b1a821c97e366793c000084\", //massey\n\"5b1a81f097e366793c000082\" //ortelius\n]; //5f529bb1b20a327b7a000001 values wall\n//5f529c43b20a327b7a00000d pet wall\n//5b1a84ed97e366793c000091 server room\n//5b196e3b97e366793c000007 hongwei's office\n\nexport default function MapScreen() {\n  var _sdkData$mapview, _sdkData$mapview$venu;\n\n  const [isFullyLoaded, setFullyLoaded] = React.useState(false);\n  const [selectedMap, setSelectedMap] = React.useState(null);\n  const [sdkData, setSdkData] = React.useState(null);\n  const [selectedLocation, setSelectedLocation] = React.useState(null); //const [navigationNodes, setNavigationNodes] = React.useState([]);\n\n  const {\n    dispatch\n  } = useContext(StateContext);\n  const history = useHistory();\n  const markers = [{\n    key: \"fantasy-wall\",\n    location: \"5fd2799106d5276c37000000\",\n    component: /*#__PURE__*/React.createElement(Markers.LocationRedirectMarker, {\n      onActivate: () => {\n        history.push(\"fantasy_wall\");\n      }\n    })\n  }, {\n    key: \"values-wall\",\n    location: \"5f529bb1b20a327b7a000001\",\n    component: /*#__PURE__*/React.createElement(Markers.LocationRedirectMarker, {\n      onActivate: () => {\n        history.push(\"values_wall\");\n      }\n    })\n  }, {\n    key: \"pet-wall\",\n    location: \"5f529c43b20a327b7a00000d\",\n    component: /*#__PURE__*/React.createElement(Markers.LocationRedirectMarker, {\n      onActivate: () => {\n        history.push(\"pet_wall\");\n      }\n    })\n  }, {\n    key: \"server-room\",\n    location: \"5b1a84ed97e366793c000091\",\n    component: /*#__PURE__*/React.createElement(Markers.LocationRedirectMarker, {\n      onActivate: () => {\n        history.push(\"door_puzzle\");\n      }\n    })\n  }, {\n    key: \"bookcase\",\n    location: \"5b1a834697e366793c000087\",\n    component: /*#__PURE__*/React.createElement(Markers.LocationRedirectMarker, {\n      onActivate: () => {\n        history.push(\"bookcase\");\n      }\n    })\n  }];\n  const {\n    resetMarkers,\n    addMarker,\n    deleteMarker\n  } = useMarkerManager(sdkData === null || sdkData === void 0 ? void 0 : sdkData.mapview, selectedMap, markers, isFullyLoaded);\n  const [sequentialLocations, setSequentialLocations] = useSequentialSelections(SelectionOrder);\n  const options = {\n    mapview: {\n      antialias: \"AUTO\",\n      //auto apply antialiasing\n      mode: Mappedin.modes.TEST,\n      //automatically test for 3d or 2d mode\n      onDataLoaded: () => console.log(\"Data loaded\"),\n      onFirstMapLoaded: () => {\n        setFullyLoaded(true);\n        console.log(\"fully loaded\");\n      }\n    },\n    venue: { ...Keys,\n      perspective: \"Website\",\n      //pick the perspective you would like to load\n      things: {\n        //fetch some data\n        venue: [\"slug\", \"name\"],\n        maps: [\"name\", \"elevation\", \"shortName\"]\n      },\n      venue: \"410-albert\"\n    }\n  };\n  const levels = sdkData === null || sdkData === void 0 ? void 0 : (_sdkData$mapview = sdkData.mapview) === null || _sdkData$mapview === void 0 ? void 0 : (_sdkData$mapview$venu = _sdkData$mapview.venue) === null || _sdkData$mapview$venu === void 0 ? void 0 : _sdkData$mapview$venu.maps.sort((a, b) => b.elevation - a.elevation);\n  const locations = sdkData === null || sdkData === void 0 ? void 0 : sdkData.mapview.venue.locations.filter(item => item.polygons && item.polygons.length > 0).sort((a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1);\n\n  const loadingCallback = data => {\n    setSdkData(data);\n    setSelectedMap(data.mapview.currentMap);\n    data.mapview.addInteractivePolygonsForAllLocations();\n    data.mapview.labelAllLocations();\n  };\n  /*\n  const addNavigationNode = (node) => {\n    const { mapview: mapView } = sdkData;\n     setNavigationNodes((prevVal) => {\n      if (prevVal[0]) {\n        prevVal[0].directionsTo(\n          node,\n          { accessible: false, directionsProvider: \"offline\" },\n          function (error, directions) {\n            if (error || directions.path.length == 0) {\n              // Some kind of network error, or those two points aren't connected, or are invalid\n              return;\n            }\n             mapView.clearAllPolygonColors();\n             if (node?.polygons) {\n              mapView.setPolygonColor(node.polygons[0], 0xbf4320);\n            } else {\n              mapView.setPolygonColor(node, 0xbf4320);\n            }\n             if (prevVal[0].polygons) {\n              mapView.setPolygonColor(prevVal[0].polygons[0], 0xbf4320);\n            } else {\n              mapView.setPolygonColor(prevVal[0], 0xbf4320);\n            }\n             mapView.removeAllPaths();\n            mapView.drawPath(directions.path);\n            mapView.focusOnPath(\n              directions.path,\n              [node, prevVal[0]],\n              true,\n              2000\n            );\n          }\n        );\n         return [node, prevVal[0]];\n      }\n      return [node];\n    });\n  };\n   */\n\n\n  const onPolygonClicked = React.useCallback(polygonId => {\n    const location = getLocationForPolygon(polygonId, sdkData.mapview);\n    sdkData.mapview.clearAllPolygonColors();\n    setSelectedLocation(location.id);\n    setSequentialLocations(location.id);\n  }, [sdkData, selectedMap]); //Respond to update of selected location\n\n  /* \n   // Do stuff on specific polygon click\n   React.useEffect(() => {\n    console.log(selectedLocation);\n     if (sdkData && sdkData.mapview && selectedLocation) {\n      const polygon = getPolygonForLocation(selectedLocation, sdkData.mapview);\n       switch (selectedLocation) {\n        case \"5b1a817c97e366793c000080\":\n          //Da Vinci\n           const markerComponent = (\n            <Markers.LocationRedirectMarker\n              text=\"Hello DaVinci\"\n              onActivate={() => {\n                history.push(\"/2\");\n                deleteMarker(\"da-vinci-marker\");\n              }}\n            />\n          );\n           addMarker({\n            key: \"da-vinci-marker\",\n            location: \"5b1a817c97e366793c000080\",\n            component: markerComponent,\n          });\n      }\n    }\n  }, [selectedLocation, sdkData]);\n   */\n  //Respond to update of sequential locations\n\n  React.useEffect(() => {\n    if (sdkData && sequentialLocations.length > 0) {\n      sequentialLocations.forEach(locationID => {\n        const polygon = getPolygonForLocation(locationID, sdkData.mapview);\n\n        if (polygon) {\n          sdkData.mapview.setPolygonColor(polygon, 0xbf4320);\n        }\n      });\n\n      if (sequentialLocations.length === SelectionOrder.length) {\n        history.push(\"sphinx_code\");\n        dispatch({\n          type: ActionTypes.completePuzzle,\n          payload: \"MEETING_ROOM\"\n        });\n      }\n    }\n  }, [sequentialLocations, sdkData, selectedMap]); //Avoid a stale closure by wrapping the function assignment in a useEffect and callback function in useCallback\n\n  React.useEffect(() => {\n    if (sdkData && sdkData.mapview) {\n      sdkData.mapview.onPolygonClicked = onPolygonClicked;\n    }\n  }, [sdkData, onPolygonClicked]);\n\n  const onLevelChange = e => {\n    setSelectedMap(e.target.value);\n  };\n\n  const onLocationChange = e => {\n    const polygon = getPolygonForLocation(e.target.value, sdkData.mapview);\n\n    if (polygon) {\n      //setNavigationNodes([polygon]);\n      sdkData.mapview.removeAllPaths();\n      sdkData.mapview.clearAllPolygonColors();\n      sdkData.mapview.setPolygonColor(polygon, 0xbf4320);\n\n      if (polygon.map !== selectedMap) {\n        setSelectedMap(polygon.map);\n        setTimeout(() => {\n          sdkData.mapview.focusOnPolygon(polygon);\n        }, 100);\n      } else {\n        sdkData.mapview.focusOnPolygon(polygon);\n      }\n    }\n\n    setSelectedLocation(e.target.value);\n  };\n\n  return /*#__PURE__*/React.createElement(Wrapper, {\n    key: \"map-container\"\n  }, /*#__PURE__*/React.createElement(StyledStatusBar, null), !isFullyLoaded && /*#__PURE__*/React.createElement(LoadingScreen, null, /*#__PURE__*/React.createElement(Spinner, null)), /*#__PURE__*/React.createElement(MappedinMap, {\n    selectedMap: selectedMap,\n    options: options,\n    onLoad: loadingCallback\n  }));\n}","map":{"version":3,"sources":["/Users/raghavsethi/Desktop/mappedin/software/webspring/src/components/apps/map-view/index.js"],"names":["React","useContext","ReactDOM","useHistory","Mappedin","Keys","Spinner","MappedinMap","Markers","useSequentialSelections","useMarkerManager","getLocationForPolygon","getPolygonForLocation","Wrapper","Row","LoadingScreen","StyledStatusBar","InterfaceContainer","StateContext","ActionTypes","SelectionOrder","MapScreen","isFullyLoaded","setFullyLoaded","useState","selectedMap","setSelectedMap","sdkData","setSdkData","selectedLocation","setSelectedLocation","dispatch","history","markers","key","location","component","push","resetMarkers","addMarker","deleteMarker","mapview","sequentialLocations","setSequentialLocations","options","antialias","mode","modes","TEST","onDataLoaded","console","log","onFirstMapLoaded","venue","perspective","things","maps","levels","sort","a","b","elevation","locations","filter","item","polygons","length","name","toLowerCase","loadingCallback","data","currentMap","addInteractivePolygonsForAllLocations","labelAllLocations","onPolygonClicked","useCallback","polygonId","clearAllPolygonColors","id","useEffect","forEach","locationID","polygon","setPolygonColor","type","completePuzzle","payload","onLevelChange","e","target","value","onLocationChange","removeAllPaths","map","setTimeout","focusOnPolygon"],"mappings":"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","sourcesContent":["import React, { useContext } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { useHistory } from \"react-router-dom\";\n\nimport Mappedin from \"@mappedin/mappedin-js/builds/mappedin\";\n\nimport Keys from \"../../../keys\";\nimport Spinner from \"../../shared/spinner\";\nimport MappedinMap from \"./MappedinMapview\";\n\nimport Markers from \"./markers\";\n\nimport {\n  useSequentialSelections,\n  useMarkerManager,\n  getLocationForPolygon,\n  getPolygonForLocation,\n} from \"./utils\";\n\nimport {\n  Wrapper,\n  Row,\n  LoadingScreen,\n  StyledStatusBar,\n  InterfaceContainer,\n} from \"./index.style\";\nimport { StateContext, ActionTypes } from \"../../util/useApplicationState\";\n\nconst SelectionOrder = [\n  \"5b1a820697e366793c000083\", //ptolemy\n  \"5b1a81db97e366793c000081\", //mercator\n  \"5b1a817c97e366793c000080\", //da vinci\n  \"5b1a814f97e366793c00007f\", //tomlinson\n  \"5b1a821c97e366793c000084\", //massey\n  \"5b1a81f097e366793c000082\", //ortelius\n];\n\n//5f529bb1b20a327b7a000001 values wall\n//5f529c43b20a327b7a00000d pet wall\n//5b1a84ed97e366793c000091 server room\n//5b196e3b97e366793c000007 hongwei's office\n\nexport default function MapScreen() {\n  const [isFullyLoaded, setFullyLoaded] = React.useState(false);\n  const [selectedMap, setSelectedMap] = React.useState(null);\n  const [sdkData, setSdkData] = React.useState(null);\n  const [selectedLocation, setSelectedLocation] = React.useState(null);\n  //const [navigationNodes, setNavigationNodes] = React.useState([]);\n  const {\n    dispatch,\n  } = useContext(StateContext);\n\n  const history = useHistory();\n\n  const markers = [\n    {\n      key: \"fantasy-wall\",\n      location: \"5fd2799106d5276c37000000\",\n      component: (\n        <Markers.LocationRedirectMarker\n          onActivate={() => {\n            history.push(\"fantasy_wall\");\n          }}\n        />\n      ),\n    },\n    {\n      key: \"values-wall\",\n      location: \"5f529bb1b20a327b7a000001\",\n      component: (\n        <Markers.LocationRedirectMarker\n          onActivate={() => {\n            history.push(\"values_wall\");\n          }}\n        />\n      ),\n    },\n    {\n      key: \"pet-wall\",\n      location: \"5f529c43b20a327b7a00000d\",\n      component: (\n        <Markers.LocationRedirectMarker\n          onActivate={() => {\n            history.push(\"pet_wall\");\n          }}\n        />\n      ),\n    },\n    {\n      key: \"server-room\",\n      location: \"5b1a84ed97e366793c000091\",\n      component: (\n        <Markers.LocationRedirectMarker\n          onActivate={() => {\n            history.push(\"door_puzzle\");\n          }}\n        />\n      ),\n    },\n    {\n      key: \"bookcase\",\n      location: \"5b1a834697e366793c000087\",\n      component: (\n        <Markers.LocationRedirectMarker\n          onActivate={() => {\n            history.push(\"bookcase\");\n          }}\n        />\n      ),\n    },\n  ];\n\n  const { resetMarkers, addMarker, deleteMarker } = useMarkerManager(\n    sdkData?.mapview,\n    selectedMap,\n    markers,\n    isFullyLoaded\n  );\n\n  const [sequentialLocations, setSequentialLocations] = useSequentialSelections(\n    SelectionOrder\n  );\n\n  const options = {\n    mapview: {\n      antialias: \"AUTO\", //auto apply antialiasing\n      mode: Mappedin.modes.TEST, //automatically test for 3d or 2d mode\n      onDataLoaded: () => console.log(\"Data loaded\"),\n      onFirstMapLoaded: () => {\n        setFullyLoaded(true);\n        console.log(\"fully loaded\");\n      },\n    },\n    venue: {\n      ...Keys,\n      perspective: \"Website\", //pick the perspective you would like to load\n      things: {\n        //fetch some data\n        venue: [\"slug\", \"name\"],\n        maps: [\"name\", \"elevation\", \"shortName\"],\n      },\n      venue: \"410-albert\",\n    },\n  };\n\n  const levels = sdkData?.mapview?.venue?.maps.sort(\n    (a, b) => b.elevation - a.elevation\n  );\n\n  const locations = sdkData?.mapview.venue.locations\n    .filter((item) => item.polygons && item.polygons.length > 0)\n    .sort((a, b) => (a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1));\n\n  const loadingCallback = (data) => {\n    setSdkData(data);\n    setSelectedMap(data.mapview.currentMap);\n\n    data.mapview.addInteractivePolygonsForAllLocations();\n    data.mapview.labelAllLocations();\n  };\n\n  /*\n  const addNavigationNode = (node) => {\n    const { mapview: mapView } = sdkData;\n\n    setNavigationNodes((prevVal) => {\n      if (prevVal[0]) {\n        prevVal[0].directionsTo(\n          node,\n          { accessible: false, directionsProvider: \"offline\" },\n          function (error, directions) {\n            if (error || directions.path.length == 0) {\n              // Some kind of network error, or those two points aren't connected, or are invalid\n              return;\n            }\n\n            mapView.clearAllPolygonColors();\n\n            if (node?.polygons) {\n              mapView.setPolygonColor(node.polygons[0], 0xbf4320);\n            } else {\n              mapView.setPolygonColor(node, 0xbf4320);\n            }\n\n            if (prevVal[0].polygons) {\n              mapView.setPolygonColor(prevVal[0].polygons[0], 0xbf4320);\n            } else {\n              mapView.setPolygonColor(prevVal[0], 0xbf4320);\n            }\n\n            mapView.removeAllPaths();\n            mapView.drawPath(directions.path);\n            mapView.focusOnPath(\n              directions.path,\n              [node, prevVal[0]],\n              true,\n              2000\n            );\n          }\n        );\n\n        return [node, prevVal[0]];\n      }\n      return [node];\n    });\n  };\n\n  */\n\n  const onPolygonClicked = React.useCallback(\n    (polygonId) => {\n      const location = getLocationForPolygon(polygonId, sdkData.mapview);\n\n      sdkData.mapview.clearAllPolygonColors();\n      setSelectedLocation(location.id);\n      setSequentialLocations(location.id);\n    },\n    [sdkData, selectedMap]\n  );\n  //Respond to update of selected location\n\n  /* \n\n  // Do stuff on specific polygon click\n\n  React.useEffect(() => {\n    console.log(selectedLocation);\n\n    if (sdkData && sdkData.mapview && selectedLocation) {\n      const polygon = getPolygonForLocation(selectedLocation, sdkData.mapview);\n\n      switch (selectedLocation) {\n        case \"5b1a817c97e366793c000080\":\n          //Da Vinci\n\n          const markerComponent = (\n            <Markers.LocationRedirectMarker\n              text=\"Hello DaVinci\"\n              onActivate={() => {\n                history.push(\"/2\");\n                deleteMarker(\"da-vinci-marker\");\n              }}\n            />\n          );\n\n          addMarker({\n            key: \"da-vinci-marker\",\n            location: \"5b1a817c97e366793c000080\",\n            component: markerComponent,\n          });\n      }\n    }\n  }, [selectedLocation, sdkData]);\n\n  */\n\n  //Respond to update of sequential locations\n  React.useEffect(() => {\n    if (sdkData && sequentialLocations.length > 0) {\n      sequentialLocations.forEach((locationID) => {\n        const polygon = getPolygonForLocation(locationID, sdkData.mapview);\n        if (polygon) {\n          sdkData.mapview.setPolygonColor(polygon, 0xbf4320);\n        }\n      });\n\n      if (sequentialLocations.length === SelectionOrder.length) {\n        history.push(\"sphinx_code\");\n        dispatch({ type: ActionTypes.completePuzzle, payload: \"MEETING_ROOM\" });\n      }\n    }\n  }, [sequentialLocations, sdkData, selectedMap]);\n\n  //Avoid a stale closure by wrapping the function assignment in a useEffect and callback function in useCallback\n  React.useEffect(() => {\n    if (sdkData && sdkData.mapview) {\n      sdkData.mapview.onPolygonClicked = onPolygonClicked;\n    }\n  }, [sdkData, onPolygonClicked]);\n\n  const onLevelChange = (e) => {\n    setSelectedMap(e.target.value);\n  };\n\n  const onLocationChange = (e) => {\n    const polygon = getPolygonForLocation(e.target.value, sdkData.mapview);\n\n    if (polygon) {\n      //setNavigationNodes([polygon]);\n      sdkData.mapview.removeAllPaths();\n      sdkData.mapview.clearAllPolygonColors();\n      sdkData.mapview.setPolygonColor(polygon, 0xbf4320);\n\n      if (polygon.map !== selectedMap) {\n        setSelectedMap(polygon.map);\n        setTimeout(() => {\n          sdkData.mapview.focusOnPolygon(polygon);\n        }, 100);\n      } else {\n        sdkData.mapview.focusOnPolygon(polygon);\n      }\n    }\n\n    setSelectedLocation(e.target.value);\n  };\n\n  return (\n    <Wrapper key=\"map-container\">\n      <StyledStatusBar />\n      {!isFullyLoaded && (\n        <LoadingScreen>\n          <Spinner />\n        </LoadingScreen>\n      )}\n\n      <MappedinMap\n        selectedMap={selectedMap}\n        options={options}\n        onLoad={loadingCallback}\n      />\n    </Wrapper>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}